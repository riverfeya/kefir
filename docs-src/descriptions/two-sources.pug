h2#combine-two Комбинирование двух observables

p.
  Как и в разделе <a href="#modify">"Изменение observable"</a> section,
  большинство методов в этом разделе будут возвращать observable того же типа, что и исходное
  observable (для которого был вызван метод).



+descr-method('filter-by', 'filterBy', 'obs.filterBy(otherObs)').
  Работает как <a href="#filter">filter</a>, но вместо того, чтобы вызывать предикат
  для каждого значения из #[b obs] observable, он проверяет последнее значение из #[b otherObs].

pre.javascript(title='example')
  :escapehtml
    var foo = Kefir.sequentially(100, [1, 2, 3, 4, 5, 6, 7, 8]);
    var bar = Kefir.sequentially(200, [false, true, false]).delay(40).toProperty(() => true);
    var result = foo.filterBy(bar);
    result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.filterBy] <value> 1
    > [sequentially.filterBy] <value> 2
    > [sequentially.filterBy] <value> 5
    > [sequentially.filterBy] <value> 6
    > [sequentially.filterBy] <end>

pre(title='events in time').
  foo:     ----1----2----3----4----5----6----7----8X
  bar:    t-----------f---------t---------fX

  result:  ----1----2--------------5----6----------X
div




+descr-method('obs-sampled-by', 'sampledBy', 'obs.sampledBy(otherObs, [combinator])').
  Возвращает поток, который испускает последнее значение из #[b obs] observable
  для каждого значения из #[b otherObs]. Заканчивается, когда заканчивается #[b otherObs].

p.
  Вы также можете предоставить функцию
  #[b combinator] которая будет использоваться для значения, испускаемого потоком результатов.
  Он вызывается с последними значениями из #[b obs] и #[b otherObs] в качестве аргументов. 
  Функция #[b combinator] по умолчанию это #[tt (a,&nbsp;b)&nbsp;=&gt;&nbsp;a].

pre.javascript(title='example')
  :escapehtml
    var a = Kefir.sequentially(200, [2, 3]).toProperty(() => 1);
    var b = Kefir.interval(100, 0).delay(40).take(5);
    var result = a.sampledBy(b);
    result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.toProperty.sampledBy] <value> 1
    > [sequentially.toProperty.sampledBy] <value> 2
    > [sequentially.toProperty.sampledBy] <value> 2
    > [sequentially.toProperty.sampledBy] <value> 3
    > [sequentially.toProperty.sampledBy] <value> 3
    > [sequentially.toProperty.sampledBy] <end>

pre(title='events in time').
  a:      1---------2---------3X
  b:       ------0----0----0----0----0X

  result:  ------1----2----2----3----3X
div



+descr-method('skip-until-by', 'skipUntilBy', 'obs.skipUntilBy(otherObs)').
  Пропускает значения от #[b obs] до первого значения от #[b otherObs].

pre.javascript(title='example')
  :escapehtml
    var foo = Kefir.sequentially(100, [1, 2, 3, 4]);
    var bar = Kefir.later(250, 0);
    var result = foo.skipUntilBy(bar);
    result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.skipUntilBy] <value> 3
    > [sequentially.skipUntilBy] <value> 4
    > [sequentially.skipUntilBy] <end>

pre(title='events in time').
  foo:     ----1----2----3----4X
  bar:     -----------0X

  result:  --------------3----4X
div




+descr-method('take-until-by', 'takeUntilBy', 'obs.takeUntilBy(otherObs)').
  Принимает значения от #[b obs] до первого значения от #[b otherObs],
  т. Е. Заканчивается на первом значении от #[b otherObs].

pre.javascript(title='example')
  :escapehtml
    var foo = Kefir.sequentially(100, [1, 2, 3, 4]);
    var bar = Kefir.later(250, 0);
    var result = foo.takeUntilBy(bar);
    result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.takeUntilBy] <value> 1
    > [sequentially.takeUntilBy] <value> 2
    > [sequentially.takeUntilBy] <end>

pre(title='events in time').
  foo:     ----1----2----3----4X
  bar:     -----------0X

  result:  ----1----2-X
div




+descr-method('buffer-by', 'bufferBy', 'obs.bufferBy(otherObs, [options])').
  Буферизует все значения из #[b obs] observable, и очищает буфер для каждого
  значения из #[b otherObs]. Также очищает буфер перед завершением.

p.
  Если #[tt options.flushOnEnd] имеет значение #[tt false], буфер не будет завершен,
  когда завершится основной observable.

p.
  result observable будет выдавать #[tt []] в случаях, когда буфер должен быть очищен, 
  но он пуст.


pre.javascript(title='example')
  :escapehtml
    var foo = Kefir.sequentially(100, [1, 2, 3, 4, 5, 6, 7, 8]).delay(40);
    var bar = Kefir.sequentially(300, [1, 2])
    var result = foo.bufferBy(bar);
    result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.delay.bufferBy] <value> [1, 2]
    > [sequentially.delay.bufferBy] <value> [3, 4, 5]
    > [sequentially.delay.bufferBy] <value> [6, 7, 8]
    > [sequentially.delay.bufferBy] <end>

pre(title='events in time').
  foo:     ------1----2----3----4----5----6----7----8 X
  bar:     --------------1--------------2X

  result:  --------------•--------------•------------•X
                    [1, 2]      [3, 4, 5]    [6, 7, 8]
div





+descr-method('buffer-while-by', 'bufferWhileBy', 'obs.bufferWhileBy(otherObs, [options])').
  Similar to #[a(href="#buffer-while") bufferWhile], но вместо использования функции предиката
  он использует другой observable.
  Для каждого значения из #[b obs] observable:
  если последнее значение из #[b otherObs] было истинным, добавляет новое значение в буфер, 
  в противном случае очищает буфер (с включенным новым значением).

p.
  Если #[tt options.flushOnEnd] имеет значение #[tt false], буфер не будет сброшен, когда
  основной observable завершится.

p.
  Если #[tt options.flushOnChange] имеет значение #[tt true], буфер также будет очищаться каждый раз,
  когда контролирующий observable выдает #[tt false].

p.
  Результирующий observable будет выдавать #[tt []] в случаях, когда буфер должен быть очищен, но он пуст.

p.
  Параметры по умолчанию #[tt {flushOnEnd: true, flushOnChange: false}].


pre.javascript(title='example')
  :escapehtml
    var foo = Kefir.sequentially(100, [1, 2, 3, 4, 5, 6, 7, 8]);
    var bar = Kefir.sequentially(200, [false, true, false]).delay(40);
    var result = foo.bufferWhileBy(bar);
    result.log();

pre(title='console output')
  :escapehtml
    > [sequentially.bufferWhileBy] <value> [1, 2, 3]
    > [sequentially.bufferWhileBy] <value> [4]
    > [sequentially.bufferWhileBy] <value> [5, 6, 7]
    > [sequentially.bufferWhileBy] <value> [8]
    > [sequentially.bufferWhileBy] <end>

pre(title='events in time').
  foo:     ----1----2----3----4----5----6----7----8X
  bar:     -----------f---------t---------fX

  result:  --------------•----•--------------•----•X
                 [1, 2, 3]  [4]      [5, 6, 7]  [8]
div
