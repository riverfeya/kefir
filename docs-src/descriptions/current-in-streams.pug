h2#current-in-streams Current values/errors в потоках

p.
  Обычно в Kefir текущие значения имеют только свойства, но в зависимости от того, 
  как мы определяем «текущее значение», мы можем сказать, что они также могут быть у потоков.

p.
  Давайте сначала посмотрим, как мы получаем текущие значения из свойств. 
  Нет прямого доступа к текущему значению свойства, мы не можем сделать что-то вроде
  #[tt prop.getCurrent()]. Вместо этого мы подписываемся на свойство, используя, например,
  #[tt onValue(callback)], и наш обратный вызов немедленно вызывается с текущим значением.

p.
  Если мы определим «текущее значение» через эту техническую деталь его получения: 
  текущее значение - это значение, которое мы получаем в обратном вызове сразу после подписки. 
  Тогда мы можем сказать, что иногда потоки также могут иметь текущие значения.

p.
  Рассмотрим некоторые примеры.

pre.javascript(title='example')
  :escapehtml
    // Это самый простой способ создать такой поток.
    var s1 = Kefir.stream(emitter => {
      emitter.emit(1);
    });

    // Но он может быть создан случайно или намеренно в некоторых других случаях, например,
    var s2 = Kefir.merge([Kefir.constant(1), Kefir.never()]);
    var s3 = Kefir.combine([Kefir.constant(1), Kefir.constant(1)]);

p.
  У этой функции Streams есть свои плюсы и минусы.

h3 Cons

p.
  Это значение получает только первый подписчик. Даже если это был подписчик #[tt onEnd]
  или #[tt onError], он все равно «потребляет» ("consume")  "current value".
  Рассмотрим некоторые примеры:

pre.javascript(title='example')
  :escapehtml
    var stream = Kefir.stream(emitter => {
      emitter.emit(1);
    });
    stream.onValue(x => console.log('first', x)); // logs "first 1"
    stream.onValue(x => console.log('second', x)); // не войдет


    // Даже с onError оно будет потреблено 
    var stream2 = ...
    stream.onError(fn);
    stream.onValue(x => console.log('second', x)); // не войдет

p.
  Это зафиксировано в свойствах, поскольку они запоминают последнее значение и вызывают с ним любого нового подписчика.

p.
  Другая проблема в том, что это не очень хорошо с точки зрения семантики. 
  Момент, когда в потоке происходит событие, зависит от момента, когда поток
  получает первого подписчика.
  Это делает подписку не чистой операцией, а вся система становится менее декларативной и функциональной.


h3 Pros

p.
  Эта функция позволяет вам определять текущее значение в потоке. Что ж, это звучит так же, 
  как определение функции, но давайте просто посмотрим на пример, надеюсь, он поможет вам понять, что я имею в виду:

pre.javascript(title='example')
  :escapehtml
    var scrollTopStream = Kefir.stream(emitter => {
      emitter.emit(window.scrollY); // здесь мы выдаем текущее значение!
      window.addEventListener('scroll', () => {
        emitter.emit(window.scrollY);
      });
    });

    // Давайте теперь превратим его в property как у хороших граждан
    var scrollTopProperty = scrollTopStream.toProperty();

p.
  Еще одно преимущество заключается в том, что это позволяет не терять текущие значения
  при преобразовании свойств в потоки, а затем обратно в свойства.
  Например, #[a(href='#combine') combine] всегда возвращает поток
  (#[a(href='https://github.com/kefirjs/kefir/issues/44#issuecomment-72875317') почему?])
  но он все равно будет выдавать текущее значение.
  Таким образом, можно выполнить #[tt Kefir.combine([p1, p2], fn).toProperty()],
  и получить свойство, объединенное из двух других свойств с правильным текущим значением.


h3 P.S.

p.
  Обратите внимание, что все это относится и к #[a(href='#about-errors') errors].

p.
  Также рекомендуется преобразовывать все потоки, которые могут передавать 
  текущие значения в свойства, с помощью метода #[b toProperty].
  Это должно сделать ваш код более надежным, поскольку все подписчики получат текущие значения. 
  И это просто семантически лучше, поскольку текущие значения должны находиться в свойствах.
