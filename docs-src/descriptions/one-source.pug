h2#modify Изменение observable

p.
  Большинство методов в этом разделе создают новый observable того же типа* 
  что и исходный. Новый observable применяет некоторое преобразование к каждому 
  событию из исходного и испускает результат преобразования.
  В большинстве случаев преобразование применяется только к #[b value] events,
  #[b end] и #[b error] events просто проходят через них нетронутыми.

p.
  #[b *] Например, если исходный наблюдаемый объект был потоком, 
  то новый также будет потоком. То же самое и со свойствами.



+descr-method('map', 'map', 'obs.map(fn)').
  Применяет данную функцию #[b fn] function к каждому значению из исходного observable
  и выдает значение, возвращаемое функцией #[b fn].

pre.javascript(title='пример')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 3]);
    var result = source.map(x => x + 1);
    result.log();

pre(title='вывод')
  :escapehtml
    > [sequentially.map] <value> 2
    > [sequentially.map] <value> 3
    > [sequentially.map] <value> 4
    > [sequentially.map] <end>
div

pre(title='события во времени').
  source: ---1---2---3X
  result: ---2---3---4X
div




+descr-method('map-errors', 'mapErrors', 'obs.mapErrors(fn)').
  То же, что и #[a(href='#map') map] но для #[a(href='#about-errors') ошибок].

pre.javascript(title='пример')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 3]).flatMap(Kefir.constantError);
    var result = source.mapErrors(x => x * 2);
    result.log();

pre(title='вывод')
  :escapehtml
    > [sequentially.flatMap.mapErrors] <error> 2
    > [sequentially.flatMap.mapErrors] <error> 4
    > [sequentially.flatMap.mapErrors] <error> 6
    > [sequentially.flatMap.mapErrors] <end>

pre(title='события во времени')
  :escapehtml
    source:  ---e---e---e---eX
                0   1   2   3
    result:  ---e---e---e---eX
                0   2   4   6
div




+descr-method('filter', 'filter', 'obs.filter([predicate])').
  Фильтрует значения из исходного observable
  с использованием заданной #[b predicate] функции.

p.
  Если #[b predicate] не предоставлен, будет использоваться функция #[tt x =&gt; x].

pre.javascript(title='пример')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 3]);
    var result = source.filter(x => x > 1);
    result.log();

pre(title='вывод')
  :escapehtml
    > [sequentially.filter] <value> 2
    > [sequentially.filter] <value> 3
    > [sequentially.filter] <end>

pre(title='события во времени').
  source: ---1---2---3X
  result: -------2---3X
div

p.
  См. также <a href="#filter-by">filterBy</a>.




+descr-method('filter-errors', 'filterErrors', 'obs.filterErrors([predicate])').
  То-же что и #[a(href='#filter') фильтр] но для #[a(href='#about-errors') ошибок].

pre.javascript(title='пример')
  :escapehtml
    var source = Kefir.sequentially(100, [0, 1, 2, 3]).flatMap(Kefir.constantError);
    var result = source.filterErrors(x => (x % 2) === 0);
    result.log();

pre(title='вывод')
  :escapehtml
    > [sequentially.flatMap.filterErrors] <error> 0
    > [sequentially.flatMap.filterErrors] <error> 2
    > [sequentially.flatMap.filterErrors] <end>

pre(title='события во времени')
  :escapehtml
    source:  ---e---e---e---eX
                0   1   2   3
    result:  ---e-------e----X
                0       2
div





+descr-method('take', 'take', 'obs.take(n)').
  выдает первые #[b n] значений из исходного observable, затем завершается.

pre.javascript(title='пример')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 3]);
    var result = source.take(2);
    result.log();

pre(title='вывод')
  :escapehtml
    > [sequentially.take] <value> 1
    > [sequentially.take] <value> 2
    > [sequentially.take] <end>

pre(title='события во времени').
  source: ---1---2---3X
  result: ---1---2X
div



+descr-method('take-errors', 'takeErrors', 'obs.takeErrors(n)').
  Выдает первые #[b n] #[a(href='#about-errors') ошибок] из исходного
  observable, затем завершается. Значения просто проходят сквозь.

pre.javascript(title='пример')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 3])
      .flatMap(x => Kefir.constantError(x));
    var result = source.takeErrors(2);
    result.log();

pre(title='вывод')
  :escapehtml
    > [sequentially.flatMap.takeErrors] <error> 1
    > [sequentially.flatMap.takeErrors] <error> 2
    > [sequentially.flatMap.takeErrors] <end>

pre(title='события во времени').
  source: ---e---e---eX
             1   2   3
  result: ---e---eX
             1   2
div



+descr-method('take-while', 'takeWhile', 'obs.takeWhile([predicate])').
  значения из исходного observable пока данная функция #[b predicate]
  примененная к значению, не вернет false.
  Заканчивается, когда #[b predicate] возвращает false.

p.
  Если #[b predicate] не предоставлен, будет использована функция #[tt x =&gt; x]

pre.javascript(title='пример')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 3]);
    var result = source.takeWhile(x => x < 3);
    result.log();

pre(title='вывод')
  :escapehtml
    > [sequentially.takeWhile] <value> 1
    > [sequentially.takeWhile] <value> 2
    > [sequentially.takeWhile] <end>

pre(title='события во времени').
  source: ---1---2---3X
  result: ---1---2---X
div

p.
  См. также <a href="#take-while-by">takeWhileBy</a>.



+descr-method('last', 'last', 'obs.last()').
  Выдает только последнее значение из исходного observable.

pre.javascript(title='пример')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 3]);
    var result = source.last();
    result.log();

pre(title='вывод')
  :escapehtml
    > [sequentially.last] <value> 3
    > [sequentially.last] <end>

pre(title='события во времени').
  source: ---1---2---3X
  result: -----------3X
div


+descr-method('skip', 'skip', 'obs.skip(n)').
  Пропускает первые #[b n] значений из исходного observable, затем выводит все остальные.

pre.javascript(title='пример')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 3]);
    var result = source.skip(2);
    result.log();

pre(title='вывод')
  :escapehtml
    > [sequentially.skip] <value> 3
    > [sequentially.skip] <end>

pre(title='события во времени').
  source: ---1---2---3X
  result: -----------3X
div



+descr-method('skip-while', 'skipWhile', 'obs.skipWhile([predicate])').
  Пропускает значения из исходного наблюдаемого до тех пор, пока данная функция #[b predicate]
  function примененная к значению, не вернет false,
  затем прекращает применение #[b predicate] к значениям и генерирует их все.

p.
  Если #[b predicate] не предоставлен, будет использована функция #[tt x =&gt; x]

pre.javascript(title='пример')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 3, 2]);
    var result = source.skipWhile(x => x < 3);
    result.log();

pre(title='вывод')
  :escapehtml
    > [sequentially.skipWhile] <value> 3
    > [sequentially.skipWhile] <value> 2
    > [sequentially.skipWhile] <end>

pre(title='события во времени').
  source: ---1---3---2X
  result: -------3---2X
div



+descr-method('skip-duplicates', 'skipDuplicates', 'obs.skipDuplicates([comparator])').
  Пропускает дублирующиеся значения используя для сравнения #[tt ===] .
  Принимает опциональную функцию #[b comparator] которая затем используется вместо #[tt ===].

pre.javascript(title='пример')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 2, 3, 1]);
    var result = source.skipDuplicates();
    result.log();

pre(title='вывод')
  :escapehtml
    > [sequentially.skipDuplicates] <value> 1
    > [sequentially.skipDuplicates] <value> 2
    > [sequentially.skipDuplicates] <value> 3
    > [sequentially.skipDuplicates] <value> 1
    > [sequentially.skipDuplicates] <end>

pre(title='события во времени').
  source: ---1---2---2---3---1X
  result: ---1---2-------3---1X
div

p С кастомной функцией #[b comparator]:

pre.javascript(title='пример')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 2.1, 3, 1]);
    var result = source.skipDuplicates(
      (a, b) => Math.round(a) === Math.round(b)
    );
    result.log();

pre(title='вывод')
  :escapehtml
    > [sequentially.skipDuplicates] <value> 1
    > [sequentially.skipDuplicates] <value> 2
    > [sequentially.skipDuplicates] <value> 3
    > [sequentially.skipDuplicates] <value> 1
    > [sequentially.skipDuplicates] <end>

pre(title='события во времени').
  source: ---1---2---•---3---1X
                   2.1
  result: ---1---2-------3---1X
div



+descr-method('diff', 'diff', 'obs.diff([fn], [seed])').
  Для каждого значения из исходного observable, вызывает функцию #[b fn]
  function с предыдущим и текущим значениями в качестве аргументов.
  В первый раз вызывает #[b fn] с #[b seed] и current значением.
  Испускает все, что возвращает #[b fn].

p.
  Если начальное значение #[b seed] не указано, первое значение будет использоваться 
  в качестве начального значения, а наблюдаемый результат не будет генерировать первое значение.

p.
  Если функция #[b fn] не указана, будет использоваться #[tt (a, b) =&gt; [a, b]].
  Если вы хотите опустить #[b fn] но указать #[b seed], передайте #[tt null] как #[b fn].

pre.javascript(title='пример')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 2, 3]);
    var result = source.diff((prev, next) => next - prev, 0);
    result.log();

pre(title='вывод')
  :escapehtml
    > [sequentially.diff] <value> 1
    > [sequentially.diff] <value> 1
    > [sequentially.diff] <value> 0
    > [sequentially.diff] <value> 1
    > [sequentially.diff] <end>

pre(title='события во времени').
  source: ---1---2---2---3X
  result: ---1---1---0---1X
div



+descr-method('scan', 'scan', 'obs.scan(fn, [seed])').
  Для каждого значения из исходного
  observable, вызывает функцию #[b fn] с предыдущим результатом, 
  возвращаемым #[b fn] и текущим значением, выданным исходным observable.
  В первый раз вызывает #[b fn] с #[b seed] в качестве предыдущего результата.
  Испускает все, что возвращает #[b fn]. Всегда создает property.

p.
  Если начальное значение #[b seed] не указано, то первое значение будет использоваться в качестве seed.

pre.javascript(title='пример')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 2, 3]);
    var result = source.scan((prev, next) => next + prev, 0);
    result.log();

pre(title='вывод')
  :escapehtml
    > [sequentially.scan] <value:current> 0
    > [sequentially.scan] <value> 1
    > [sequentially.scan] <value> 3
    > [sequentially.scan] <value> 5
    > [sequentially.scan] <value> 8
    > [sequentially.scan] <end>

pre(title='события во времени').
  source:  ---1---2---2---3X
  result: 0---1---3---5---8X
div




+descr-method('flatten', 'flatten', 'obs.flatten([transformer])').
  Для этого метода ожидается, что наблюдаемый поток испускает массивы. 
  Затем поток результатов будет выдавать каждый элемент этих массивов.

p.
  Всегда возвращает поток.

pre.javascript(title='пример')
  :escapehtml
    var source = Kefir.sequentially(100, [[1], [], [2,3]]);
    var result = source.flatten();
    result.log();

pre(title='вывод')
  :escapehtml
    > [sequentially.flatten] <value> 1
    > [sequentially.flatten] <value> 2
    > [sequentially.flatten] <value> 3
    > [sequentially.flatten] <end>

pre(title='события во времени').
  source:  --------•--------•-------- •X
                 [1]       []     [2,3]
  result:  --------1-----------------23X
div

p.
  Вы также можете предоставить функцию-преобразователь - #[b transformer]
  которая будет применяться к каждому значению из #[b obs] observable,
  и должна возвращать массив. Это делает #[b flatten] довольно мощным методом преобразования. 
  Он позволяет выполнять три вида преобразований для каждого значения:
  изменять значение (такое как map), пропускать значение (такие как filter),
  и отвечать несколькими значениями на одно значение.
  Если вы хотите пропустить значение, верните пустой массив, для изменения значения - 
  верните массив с одним новым значением, чтобы выдать несколько значений - верните их в массиве.

pre.javascript(title='пример')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 3, 4]);
    var result = source.flatten(x => {
      if (x % 2 === 0) {
        return [x * 10];
      } else {
        return [];
      }
    });
    result.log();

pre(title='вывод')
  :escapehtml
    > [sequentially.flatten] <value> 20
    > [sequentially.flatten] <value> 40
    > [sequentially.flatten] <end>

pre(title='события во времени').
  source:  ---1---2---3---4X
  result:  -------•-------•X
                 20      40
div

p.
  См. также <a href="#flat-map">flatMap</a>



+descr-method('delay', 'delay', 'obs.delay(wait)').
  Задерживает все события на #[b wait] milliseconds,
  за исключением текущего значения свойства или конца уже завершившегося
  observable. Не задерживает #[a(href='#about-errors') errors].

pre.javascript(title='пример')
  :escapehtml
    var source = Kefir.sequentially(200, [1, 2, 3]);
    var result = source.delay(100);
    result.log();


pre(title='вывод')
  :escapehtml
    > [sequentially.delay] <value> 1
    > [sequentially.delay] <value> 2
    > [sequentially.delay] <value> 3
    > [sequentially.delay] <end>

pre(title='события во времени').
  source:  -----1-----2-----3X
  result:  --------1-----2-----3X
div



+descr-method('throttle', 'throttle', 'obs.throttle(wait, [options])').
  Возвращает новую throttled версию исходного observable, который будет выдавать значения не чаще одного раза в
  #[b wait] милисекунд.
  Если используется property, текущее значение всегда будет передаваться без задержки.

p.
  Принимает необязательный объект #[b options] аналогичный
  <a href="http://underscorejs.org/#throttle" target="_blank">underscore.throttle</a>.
  По умолчанию он генерирует событие, как только оно происходит в первый раз, и, 
  если какое-либо новое событие происходит в течение периода ожидания, 
  оно генерирует последнее из них, как только этот период заканчивается.
  Если вы хотите отключить leading-edge emit,
  передайте #[tt {leading: false}]. И если вы хотите отключить emit
  в trailing-edge, передайте #[tt {trailing: false}].

pre.javascript(title='пример')
  :escapehtml
    var source = Kefir.sequentially(750, [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]);
    var result = source.throttle(2500);
    result.log();

pre(title='вывод')
  :escapehtml
    > [sequentially.throttle] <value> 1
    > [sequentially.throttle] <value> 4
    > [sequentially.throttle] <value> 7
    > [sequentially.throttle] <value> 0
    > [sequentially.throttle] <end>
div

pre(title='события во времени').
  source:  --1--2--3--4--5--6--7--8--9--0X
  result:  --1---------4---------7---------0X
div




+descr-method('debounce', 'debounce', 'obs.debounce(wait, [options])').
  Создает новую отклоненную (debounced) версию исходного observable.
  Будет выдавать значение только после периода отсутствия событий в #[b wait] милисекунд.
  Передайте #[tt {immediate: true}] как объект #[b options] чтобы
  observable выдавал значение на ведущем (leading) а не trailing крае интервала #[b wait].
  Если используется property, текущее значение всегда будет передаваться без задержки.

pre.javascript(title='пример')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 3, 0, 0, 0, 4, 5, 6]);
    source = source.filter(x => x > 0);
    var result = source.debounce(250);
    result.log();

pre(title='вывод')
  :escapehtml
    > [sequentially.filter.debounce] <value> 3
    > [sequentially.filter.debounce] <value> 6
    > [sequentially.filter.debounce] <end>
div

pre(title='события во времени').
  source:  ---1---2---3---------------4---5---6X
  result:  ----------------------3---------------------6X
div




+descr-method('ignore-values', 'ignoreValues', 'obs.ignoreValues()').
  Игнорирует все значения из исходного observable, выдает только ошибки и конец.

pre.javascript(title='пример')
  :escapehtml
    var source = Kefir.sequentially(100, [0, -1, 2, -3])
      .flatMap(x => x < 0 ? Kefir.constantError(x) : Kefir.constant(x));
    var result = source.ignoreValues()
    result.log();

pre(title='вывод')
  :escapehtml
    > [sequentially.flatMap.ignoreValues] <error> -1
    > [sequentially.flatMap.ignoreValues] <error> -3
    > [sequentially.flatMap.ignoreValues] <end>

pre(title='события во времени')
  :escapehtml
    source:  ---•---e---•---eX
                0  -1   2  -3
    result:  -------e-------eX
                   -1      -3
div




+descr-method('ignore-errors', 'ignoreErrors', 'obs.ignoreErrors()').
Игнорирует все ошибки из исходного observable, выдает только значения и конец.

pre.javascript(title='пример')
  :escapehtml
    var source = Kefir.sequentially(100, [0, -1, 2, -3])
      .flatMap(x => x < 0 ? Kefir.constantError(x) : Kefir.constant(x));
    var result = source.ignoreErrors()
    result.log();

pre(title='вывод')
  :escapehtml
    > [sequentially.flatMap.ignoreErrors] <value> 0
    > [sequentially.flatMap.ignoreErrors] <value> 2
    > [sequentially.flatMap.ignoreErrors] <end>

pre(title='события во времени')
  :escapehtml
    source:  ---•---e---•---eX
                0  -1   2  -3
    result:  ---•-------•----X
                0       2
div



+descr-method('ignore-end', 'ignoreEnd', 'obs.ignoreEnd()').
  Игнорирует end исходного observable.

pre.javascript(title='пример')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 3]);
    var result = source.ignoreEnd();
    result.log();

pre(title='вывод')
  :escapehtml
    > [sequentially.ignoreEnd] <value> 1
    > [sequentially.ignoreEnd] <value> 2
    > [sequentially.ignoreEnd] <value> 3

pre(title='события во времени').
  source:  ---1---2---3X
  result:  ---1---2---3---
div




+descr-method('before-end', 'beforeEnd', 'obs.beforeEnd(fn)').
  Позволяет вам вставить дополнительное значение непосредственно перед завершением observable.
  #[b fn] будет вызываться в конце #[b obs]'  без аргументов, и все, что он вернет,
  будет передано в поток результатов до конца.

pre.javascript(title='пример')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 3]);
    var result = source.beforeEnd(() => 0);
    result.log();

pre(title='вывод')
  :escapehtml
    > [sequentially.beforeEnd] <value> 1
    > [sequentially.beforeEnd] <value> 2
    > [sequentially.beforeEnd] <value> 3
    > [sequentially.beforeEnd] <value> 0
    > [sequentially.beforeEnd] <end>

pre(title='события во времени').
  source:  ---1---2---3 X
  result:  ---1---3---30X
div



+descr-method('sliding-window', 'slidingWindow', 'obs.slidingWindow(max, [min])').
  Будет выдавать массивы, содержащие последние #[b n] значений из #[b obs] observable,
  где #[b n] находится между #[b max] и #[b min] аргументами.
  По умолчанию #[b min] равно #[tt 0].

pre.javascript(title='пример')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 3, 4, 5]);
    var result = source.slidingWindow(3, 2)
    result.log();

pre(title='вывод')
  :escapehtml
    > [sequentially.slidingWindow] <value> [1, 2]
    > [sequentially.slidingWindow] <value> [1, 2, 3]
    > [sequentially.slidingWindow] <value> [2, 3, 4]
    > [sequentially.slidingWindow] <value> [3, 4, 5]
    > [sequentially.slidingWindow] <end>

pre(title='события во времени').
  source:  --------1--------2--------3--------4--------5X
  result:  -----------------•--------•--------•--------•X
                        [1,2]  [1,2,3]  [2,3,4]  [3,4,5]
div




+descr-method('buffer-while', 'bufferWhile', 'obs.bufferWhile([predicate], [options])').
  Передает каждое значение из исходного observable в функцию #[b predicate].
  Если она возвращает #[tt true], добавляет значение в буфер, в противном случае 
  очищает буфер. Также очищает буфер перед завершением, но вы можете отключить это, 
  передав #[tt {flushOnEnd: false}] как #[b options].

p.
  По умолчанию #[b predicate] это #[tt x =&gt; x].
  Если вы хотите опустить #[b predicate] но передать #[b options],
  передайте #[tt null] в качестве #[b predicate].

pre.javascript(title='пример')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 3, 4, 5]);
    var result = source.bufferWhile(x => x !== 3);
    result.log();

pre(title='вывод')
  :escapehtml
    > [sequentially.bufferWhile] <value> [1, 2, 3]
    > [sequentially.bufferWhile] <value> [4, 5]
    > [sequentially.bufferWhile] <end>

pre(title='события во времени').
  source:  ---1---2---3---4---5 X
  result:  -----------•--------•X
                [1,2,3]    [4,5]
div



+descr-method('buffer-with-count', 'bufferWithCount', 'obs.bufferWithCount(count, [options])').
  Буферизует все значения из #[b obs] observable, и очищает буфер каждый раз, когда значения
  счетчика #[b count] были пройдены.
  Также очищает буфер перед завершением, но вы можете отключить это, передав
   #[tt {flushOnEnd: false}] в качестве #[b options].

pre.javascript(title='пример')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 3, 4, 5]);
    var result = source.bufferWithCount(2);
    result.log();

pre(title='вывод')
  :escapehtml
    > [sequentially.bufferWithCount] <value> [1, 2]
    > [sequentially.bufferWithCount] <value> [3, 4]
    > [sequentially.bufferWithCount] <value> [5]
    > [sequentially.bufferWithCount] <end>

pre(title='события во времени').
  source:  --------1--------2--------3--------4--------5 X
  result:  -----------------•-----------------•---------•X
                        [1,2]             [3,4]       [5]X
div




+descr-method('buffer-with-time-or-count', 'bufferWithTimeOrCount', 'obs.bufferWithTimeOrCount(interval, count, [options])').
  Непрерывно буферизует значения из исходного observable, очищая
  каждые #[b interval] милисекунд, сразу после сохранения значений счетчика #[b count].
  Также очищает буфер перед завершением, но вы можете отключить это, передав 
  #[tt {flushOnEnd: false}] в качестве #[b options].

p.
  Ограничено по времени:

pre.javascript(title='пример')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 3, 4, 5, 6, 7, 8]);
    var result = source.bufferWithTimeOrCount(330, 10);
    result.log();

pre(title='вывод')
  :escapehtml
    > [sequentially.bufferWithTimeOrCount] <value> [1, 2, 3]
    > [sequentially.bufferWithTimeOrCount] <value> [4, 5, 6]
    > [sequentially.bufferWithTimeOrCount] <value> [7, 8]
    > [sequentially.bufferWithTimeOrCount] <end>

pre(title='события во времени').
  source:  ---1---2---3---4---5---6---7---8 X
  result:  ------------•------------•------•X
                [1,2,3]       [4,5,6]  [7,8]

p.
  Ограничено количеством :

pre.javascript(title='пример')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 3, 4, 5, 6, 7, 8]);
    var result = source.bufferWithTimeOrCount(330, 2);
    result.log();

pre(title='вывод')
  :escapehtml
    > [sequentially.bufferWithTimeOrCount] <value> [1, 2]
    > [sequentially.bufferWithTimeOrCount] <value> [3, 4]
    > [sequentially.bufferWithTimeOrCount] <value> [5, 6]
    > [sequentially.bufferWithTimeOrCount] <value> [7, 8]
    > [sequentially.bufferWithTimeOrCount] <end>

pre(title='события во времени').
  source:  ---1---2---3---4---5---6---7---8X
  result:  -------•-------•-------•-------•X
              [1,2]   [3,4]   [5,6]   [7,8]
div




+descr-method('transduce', 'transduce', 'obs.transduce(transducer)').
  Этот метод позволяет использовать преобразователи (transducers) в Kefir.
  Он поддерживает любую реализацию преобразователей, которая соответствует
  <a href="https://github.com/cognitect-labs/transducers-js#the-transducer-protocol">протоколу преобразователя</a>, 
  например
  <a href="https://github.com/cognitect-labs/transducers-js">cognitect-labs/transducers-js</a> или
  <a href="https://github.com/jlongster/transducers.js">jlongster/transducers.js</a>.
  Чтобы узнать больше о преобразователях, посетите эти страницы библиотеки.

p.
  В примере используется библиотека
  <a href="https://github.com/cognitect-labs/transducers-js">cognitect-labs/transducers-js</a>.

pre.javascript(title='пример')
  :escapehtml
    var t = transducers;
    var source = Kefir.sequentially(100, [1, 2, 3, 4, 5, 6]);
    var myTransducer = t.comp(
      t.map(x => x + 10),
      t.filter(x => x % 2 === 0),
      t.take(2)
    );
    var result = source.transduce(myTransducer);
    result.log();

pre(title='вывод')
  :escapehtml
    > [sequentially.transduce] <value> 12
    > [sequentially.transduce] <value> 14
    > [sequentially.transduce] <end>

pre(title='события во времени').
  source:  ---1---2---3---4---5---6X
  result:  -------•-------•X
                 12      14
div

+descr-method('thru', 'thru', 'obs.thru(transformer)').
  Вызывает трансформатор - #[b transformer] с аргументом #[b obs] и возвращает то, 
  что вернул трансформатор #[b transformer].
  Другими словами, #[tt o.thru(fn)] это то-же, что #[tt fn(o)]. 
  Это позволяет вам интегрировать ваши вспомогательные функции в цепочки вызовов 
  метода Kefir, не добавляя их в прототип Observable.

pre.javascript(title='пример')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 3, 4, 5, 6]);
    var transformer = obs => obs.filter(x => x > 2);
    var result = source.thru(transformer).map(x => x - 1); // is the same as transformer(source).map(...)
    result.log();
div

pre(title='события во времени').
  source:  ---1---2---3---4---5---6X
  result:  -----------2---3---4---5X
div

pre(title='вывод')
  :escapehtml
    > [sequentially.filter.map] <value> 2
    > [sequentially.filter.map] <value> 3
    > [sequentially.filter.map] <value> 4
    > [sequentially.filter.map] <value> 5
    > [sequentially.filter.map] <end>
div

+descr-method('with-handler', 'withHandler', 'obs.withHandler(handler)').
  Самый общий метод трансформации. Все остальные методы преобразования, указанные выше, 
  могут быть реализованы с помощью #[b withHandler].
  Будет вызывать функцию обработчика #[b handler] для каждого события из #[b obs] observable,
  передавая ему два аргумента: <a href="#emitter-object">emitter</a>,
  и объект event (в том же формате, что и в обратном вызове <a href="#on-any">onAny</a> ).

p.
  По умолчанию он не будет выдавать никаких значений или ошибок, и он не завершится, когда закончится #[b obs]
  observable. Вместо этого вы должны реализовать желаемое поведение 
  в функции обработчика #[b handler], то есть проанализировать объект события #[b event object] 
  и при необходимости вызвать методы эмиттера #[b emitter]. 
  Вы можете вызывать методы эмиттера #[b emitter] несколько раз при каждом выполнении обработчика #[b handler],
  а также можете вызывать их в любое время позже, например, для реализации задержки  <a href="#delay">delay</a>.

pre.javascript(title='пример')
  :escapehtml
    var source = Kefir.sequentially(100, [0, 1, 2, 3]);
    var result = source.withHandler((emitter, event) => {
      if (event.type === 'end') {
        emitter.emit('bye');
        emitter.end();
      }
      if (event.type === 'value') {
        for (var i = 0; i < event.value; i++) {
          emitter.emit(event.value);
        }
      }
    });
    result.log();

pre(title='вывод')
  :escapehtml
    > [sequentially.withHandler] <value> 1
    > [sequentially.withHandler] <value> 2
    > [sequentially.withHandler] <value> 2
    > [sequentially.withHandler] <value> 3
    > [sequentially.withHandler] <value> 3
    > [sequentially.withHandler] <value> 3
    > [sequentially.withHandler] <value> bye
    > [sequentially.withHandler] <end>
div

pre(title='события во времени').
  source:  ---0---1--- 2---  3 X
  result:  -------•---••---••••X
                  1   22   333bye
div
