h2#combine-observables Комбинирование observables



+descr-method('combine', 'combine', 'Kefir.combine(obss, [passiveObss], [combinator])', 'obs.combine(otherObs, [combinator])').
  Возвращает поток.
  Объединяет две или более observables вместе. Для каждого значения из любого
  исходного observable (#[b obss] array), генерирует комбинированное значение, 
  сгенерированное функцией комбинатора #[b combinator]
  из последних значений из каждого исходного observable. Функция комбинатор #[b combinator]
  вызывается с последними значениями в качестве аргументов.
  Если функция #[b combinator] не указан, он генерирует массив, содержащий самые последние значения.

pre.javascript(title='example')
  :escapehtml
    var a = Kefir.sequentially(100, [1, 3]);
    var b = Kefir.sequentially(100, [2, 4]).delay(40);

    var result = Kefir.combine([a, b], (a, b) => a + b);
    result.log();

pre(title='вывод')
  :escapehtml
    > [combine] <value> 3
    > [combine] <value> 5
    > [combine] <value> 7
    > [combine] <end>

pre(title='события во времени').
  a:       ----1----3X
  b:       ------2----4X

  result:  ------3--5-7X
div

p.
  Вы также можете передать часть исходных observables как #[b passiveObss] во втором массиве,
  поток результатов не будет генерировать значения из  #[b passiveObss],
  но все значения будут доступны в функции комбинатора.

pre.javascript(title='example')
  :escapehtml
    var a = Kefir.sequentially(100, [1, 3]);
    var b = Kefir.sequentially(100, [2, 4]).delay(40);
    var c = Kefir.sequentially(60, [5, 6, 7]);

    var result = Kefir.combine([a, b], [c], (a, b, c) => a + b + c);
    result.log();

pre(title='вывод')
  :escapehtml
    > [combine] <value> 9
    > [combine] <value> 12
    > [combine] <value> 14
    > [combine] <end>

pre(title='события во времени').
  a:       ----1----3X
  b:       ------2----4X
  c:       --5--6--7X

  result:  ------•--•-•X
                 9 12 14

div

p.
  Кроме того, #[b combine] поддерживает передачу объектов и как #[b obss] #[i и как] #[b passiveObss].
  Затем функция комбинатора #[b combinator] будет вызвана с одним аргументом, новым объектом 
  с последним значением из каждого observable. Если #[b combinator] не указан, сгенерируется
  объект содержащий последние значения.

pre.javascript(title='example')
  :escapehtml
    var aStream = Kefir.sequentially(100, [1, 3]);
    var bStream = Kefir.sequentially(100, [2, 4]).delay(40);

    var result = Kefir.combine({ a: aStream, b: bStream });
    result.log();

pre(title='вывод')
  :escapehtml
    > [combine] <value> { a: 1, b: 2 }
    > [combine] <value> { a: 3, b: 2 }
    > [combine] <value> { a: 3, b: 4 }
    > [combine] <end>

pre(title='события во времени').
  a:       ----1----3X
  b:       ------2----4X

  result:  ------•--•-•X

p.
  #[img(data-emoji="point_up")] Если есть повторяющиеся ключи и в #[b obss]
  #[i и в] #[b passiveObss], только последние значения из obss будут отображаться
  в объединенном объекте для дублированных ключей..

p.
  Поток результатов выдает значение только в том случае, если он имеет хотя бы одно 
  значение из каждого исходного observables . 
  Завершается, когда заканчиваются все активные исходные observables (#[b obss] array).

p.
  Вы также можете объединить два observables вызывая #[tt a.combine(b, combinator)] если хотите



+descr-method('zip', 'zip', 'Kefir.zip(sources, [combinator])', 'obs.zip(otherObs, [combinator])').
  Создает поток со значениями из #[b sources], выровненных друг с другом.
  Например Например, если у вас есть два источника с
  #[tt [1, 2, 3]] и #[tt [4, 5, 6, 7]], поток результатов будет выдавать
  #[tt [1, 4]], #[tt [2, 5]], и #[tt [3, 6]].
  Поток результатов выдаст следующее значение только в том случае, если он имеет
  хотя бы одно значение из каждого источника..

p.
  Вы также можете предоставить функцию #[b combinator]. В таком случае, вместо
  генерации массива значений, они будут переданы в функцию #[b combinator] как аргументы,
  а возвращаемое значение будет выдано  (так же, как  #[a(href="#combine") комбинации])

p.
  Так же в #[b zip] вы можете передавать обычные массивы вместе с observables
  в #[b sources], e.g. #[tt Kefir.zip([obs,&nbsp;[1,&nbsp;2,&nbsp;3]],&nbsp;fn)].
  Другими словами, #[b sources] это массив observables и массивов,
  или, конечно, только наблюдаемых.

p.
  Поток результатов заканчивается, когда заканчиваются все источники.

pre.javascript(title='example')
  :escapehtml
    var a = Kefir.sequentially(100, [0, 1, 2, 3]);
    var b = Kefir.sequentially(160, [4, 5, 6]);
    var c = Kefir.sequentially(100, [8, 9]).delay(260).toProperty(() => 7);
    var result = Kefir.zip([a, b, c]);
    result.log();

pre(title='вывод')
  :escapehtml
    > [zip] <value> [0, 4, 7]
    > [zip] <value> [1, 5, 8]
    > [zip] <value> [2, 6, 9]
    > [zip] <end>

pre(title='события во времени').
  a:    ----0----1----2----3X
  b:    -------4-------5-------6X
  c:   7-----------------8----9X

  abc:  -------•---------•-----•X
         [0,4,7]   [1,5,8]     [2,6,9]
div

p.
  #[img(data-emoji="point_up")] Иногда этот метод используется неправильно вместо
  #[a(href='#combine') combine]. Убедитесь, что вы понимаете разницу и
  делаете правильный выбор.



+descr-method('merge', 'merge', 'Kefir.merge(obss)', 'obs.merge(otherObs)').
  Объединяет несколько #[b obss] в один поток, т.е. просто повторяет значения из
  каждого наблюдаемого источника. Заканчивается, когда заканчиваются все #[b obss].

p.
  Вы также можете объединить два observablesвызвав #[tt a.merge(b)].

pre.javascript(title='example')
  :escapehtml
    var a = Kefir.sequentially(100, [0, 1, 2]);
    var b = Kefir.sequentially(100, [0, 1, 2]).delay(30);
    var c = Kefir.sequentially(100, [0, 1, 2]).delay(60);
    var abc = Kefir.merge([a, b, c]);
    abc.log();

pre(title='вывод')
  :escapehtml
    > [merge] <value> 0
    > [merge] <value> 0
    > [merge] <value> 0
    > [merge] <value> 1
    > [merge] <value> 1
    > [merge] <value> 1
    > [merge] <value> 2
    > [merge] <value> 2
    > [merge] <value> 2
    > [merge] <end>

pre(title='события во времени').
  a:    ----------0---------1---------2X
  b:    ------------0---------1---------2X
  c:    --------------0---------1---------2X

  abc:  ----------0-0-0-----1-1-1-----2-2-2X
div




+descr-method('concat', 'concat', 'Kefir.concat(obss)', 'obs.concat(otherObs)').
  Объединяет несколько #[b obss] observables в один поток. Как #[a(href="#merge") merge],
  но переключается на следующий источник только после окончания предыдущего.

pre.javascript(title='example')
  :escapehtml
    var a = Kefir.sequentially(100, [0, 1, 2]);
    var b = Kefir.sequentially(100, [3, 4, 5]);

    var abc = Kefir.concat([a, b]);
    abc.log();

pre(title='вывод')
  :escapehtml
    > [concat] <value> 0
    > [concat] <value> 1
    > [concat] <value> 2
    > [concat] <value> 3
    > [concat] <value> 4
    > [concat] <value> 5
    > [concat] <end>

pre(title='события во времени').
  a:    ---0---1---2X
  b:                ---3---4---5X

  abc:  ---0---1---2---3---4---5X
div

p.
  #[img(data-emoji="point_up")] Иногда этот метод используется неправильно вместо
  #[a(href='#merge') merge]. Убедитесь, что вы понимаете разницу и
  делаете правильный выбор.


+descr-method('pool', 'pool', 'Kefir.pool()').
  #[b Pool] похож на #[a(href="#merge") merge] к которому вы можете динамически
  добавлять и удалять источники.
  Когда вы создаете новый #[b pool] у него нет источников. Затем вы можете 
  добавить к нему observables с помощью метода #[b plug] ,
  и удалить их с помощью #[b unplug]. #[b Pool] никогда не заверщается.

pre.javascript(title='example')
  :escapehtml
    var a = Kefir.sequentially(100, [0, 1, 2]);
    var b = Kefir.sequentially(100, [0, 1, 2]).delay(30);
    var c = Kefir.sequentially(100, [0, 1, 2]).delay(60);
    var pool = Kefir.pool();
    pool.plug(a);
    pool.plug(b);
    pool.plug(c);
    pool.log();

pre(title='вывод')
  :escapehtml
    > [pool] <value> 0
    > [pool] <value> 0
    > [pool] <value> 0
    > [pool] <value> 1
    > [pool] <value> 1
    > [pool] <value> 1
    > [pool] <value> 2
    > [pool] <value> 2
    > [pool] <value> 2

pre(title='события во времени').
  a:    ----------0---------1---------2X
  b:    ------------0---------1---------2X
  c:    --------------0---------1---------2X

  pool: ----------0-0-0-----1-1-1-----2-2-2
div




+descr-method('repeat', 'repeat', 'Kefir.repeat(generator)').
  Вызывает функцию #[b generator]  которая должна возвращать observable.
  Выдает значения и ошибки из порожденного observable; когда он заканчивается,
  снова вызывает #[b generator] чтобы получить новый и так далее.

p.
  Функция #[b generator] вызывается с одним аргументом — номером итерации, 
  начиная с #[tt 0]. Если от #[b generator], возвращается ложное значение, 
  поток завершается..

pre.javascript(title='example')
  :escapehtml
    var result = Kefir.repeat(i => {
      if (i < 3) {
        return Kefir.sequentially(100, [i, i]);
      } else {
        return false;
      }
    });
    result.log();

pre(title='вывод')
  :escapehtml
    > [repeat] <value> 0
    > [repeat] <value> 0
    > [repeat] <value> 1
    > [repeat] <value> 1
    > [repeat] <value> 2
    > [repeat] <value> 2
    > [repeat] <end>

pre(title='события во времени').
  spawned 1:  ---0---0X
  spawned 2:          ---1---1X
  spawned 3:                  ---2---2X

  result:     ---0---0---1---1---2---2X
div

p.
  #[img(data-emoji="point_up")] Обратите внимание, что с помощью этого метода можно 
  создать бесконечный цикл. Рассмотрим этот пример:

pre.javascript(title='example')
  :escapehtml
    var result = Kefir.repeat(() => Kefir.constant(1));

    // Когда мы подписываемся на него (напрямую или через .log)
    // мы уже находимся в бесконечном цикле.
    result.log();

    // Но если мы ограничим его .take или чем-то еще, он будет работать нормально.
    // Итак, поток `result` определен следующим образом
    // все еще может иметь смысл, в зависимости от того, как мы его используем.
    result.take(10).log();

p.
  Еще более опасно, если #[b generator] постоянно возвращает завершенное observable
  без значений (тоесть #[a(href='#never') никогда]).
  В этом случае, #[tt .take] не поможет, потому что вы никогда не получите от него
  ни одного значения,но #[b generator] будет вызываться снова и снова.
  Единственный путь выхода здесь - определить условие выхода в генераторе #[b generator]:

pre.javascript(title='example')
  :escapehtml
    var result = Kefir.repeat(i => {

      // Определение того, что новый observable будет создаваться не более 10 раз
      if (i >= 10) {
        return false;
      }

      return Kefir.never();
    });

p.
  Так что будьте осторожны при использовании #[b repeat],
  это немного опасный, но все же отличный метод.




+descr-method('flat-map', 'flatMap', 'obs.flatMap([transform])').
  Работает аналогично <a href="#flatten">flatten</a>,
  но вместо массивов обрабатывает observables. Как и в #[b flatten] вы можете либо
  предоставить функцию #[b transform] которая будет возвращать observables,
  либо вы можете использовать исходный #[b obs] observable который уже испускает observables.

p.
  Всегда возвращает поток.

p.
  #[b flatMap] завершается, когда заканчиваются #[b obs] и все порожденные observables.

pre.javascript(title='example')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 3]);
    var result = source.flatMap(x => Kefir.interval(40, x).take(4));
    result.log();

pre(title='вывод')
  :escapehtml
    > [sequentially.flatMap] <value> 1
    > [sequentially.flatMap] <value> 1
    > [sequentially.flatMap] <value> 1
    > [sequentially.flatMap] <value> 2
    > [sequentially.flatMap] <value> 1
    > [sequentially.flatMap] <value> 2
    > [sequentially.flatMap] <value> 2
    > [sequentially.flatMap] <value> 3
    > [sequentially.flatMap] <value> 2
    > [sequentially.flatMap] <value> 3
    > [sequentially.flatMap] <value> 3
    > [sequentially.flatMap] <value> 3
    > [sequentially.flatMap] <end>

pre(title='события во времени').
  source:      ----------1---------2---------3X

  spawned 1:             ---1---1---1---1X
  spawned 2:                       ---2---2---2---2X
  spawned 3:                                 ---3---3---3---3X

  result:      -------------1---1---1-2-1-2---2-3-2-3---3---3X
div




+descr-method('flat-map-latest', 'flatMapLatest', 'obs.flatMapLatest([fn])').
  Как #[b flatMap], но повторяет события только из последнего добавленного observable
  переключается с одного observable на другой.

pre.javascript(title='example')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 3]);
    var result = source.flatMapLatest(x => Kefir.interval(40, x).take(4));
    result.log();

pre(title='вывод')
  :escapehtml
    > [sequentially.flatMapLatest] <value> 1
    > [sequentially.flatMapLatest] <value> 1
    > [sequentially.flatMapLatest] <value> 2
    > [sequentially.flatMapLatest] <value> 2
    > [sequentially.flatMapLatest] <value> 3
    > [sequentially.flatMapLatest] <value> 3
    > [sequentially.flatMapLatest] <value> 3
    > [sequentially.flatMapLatest] <value> 3
    > [sequentially.flatMapLatest] <end>

pre(title='события во времени').
  source:      ----------1---------2---------3X

  spawned 1:             ---1---1---1---1X
  spawned 2:                       ---2---2---2---2X
  spawned 3:                                 ---3---3---3---3X

  result:      -------------1---1-----2---2-----3---3---3---3X
div



+descr-method('flat-map-first', 'flatMapFirst', 'obs.flatMapFirst([fn])').
  Как #[b flatMap], но добавляет новый observable только если предыдущий завершен.
  иначе, он просто игнорирует новый observable.

pre.javascript(title='example')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 3]);
    var result = source.flatMapFirst(x => Kefir.interval(40, x).take(4));
    result.log();

pre(title='вывод')
  :escapehtml
    > [sequentially.flatMapFirst] <value> 1
    > [sequentially.flatMapFirst] <value> 1
    > [sequentially.flatMapFirst] <value> 1
    > [sequentially.flatMapFirst] <value> 1
    > [sequentially.flatMapFirst] <value> 3
    > [sequentially.flatMapFirst] <value> 3
    > [sequentially.flatMapFirst] <value> 3
    > [sequentially.flatMapFirst] <value> 3
    > [sequentially.flatMapFirst] <end>

pre(title='события во времени').
  source:      ----------1---------2---------3X

  spawned 1:             ---1---1---1---1X
  spawned 2:                       ---2---2---2---2X
  spawned 3:                                 ---3---3---3---3X

  result:      -------------1---1---1---1-------3---3---3---3X
div



+descr-method('flat-map-concat', 'flatMapConcat', 'obs.flatMapConcat([fn])').
  Like #[a(href='#flat-map-first') flatMapFirst], но вместо того, чтобы игнорировать новые observables
  (если предыдущий все еще жив), он добавляет их в очередь.
  Затем, когда текущий источник заканчивается, он берет самый старый observable из очереди,
  и переключается на него.

pre.javascript(title='example')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 3]);
    var result = source.flatMapConcat(x => Kefir.interval(40, x).take(4));
    result.log();

pre(title='вывод')
  :escapehtml
    > [sequentially.flatMapConcat] <value> 1
    > [sequentially.flatMapConcat] <value> 1
    > [sequentially.flatMapConcat] <value> 1
    > [sequentially.flatMapConcat] <value> 1
    > [sequentially.flatMapConcat] <value> 2
    > [sequentially.flatMapConcat] <value> 2
    > [sequentially.flatMapConcat] <value> 2
    > [sequentially.flatMapConcat] <value> 2
    > [sequentially.flatMapConcat] <value> 3
    > [sequentially.flatMapConcat] <value> 3
    > [sequentially.flatMapConcat] <value> 3
    > [sequentially.flatMapConcat] <value> 3
    > [sequentially.flatMapConcat] <end>

pre(title='события во времени').
  source:      ----------1---------2---------3X

  spawned 1:             ---1---1---1---1X
  spawned 2:                             ---2---2---2---2X
  spawned 3:                                             ---3---3---3---3X

  result:      -------------1---1---1---1---2---2---2---2---3---3---3---3X
div



+descr-method('flat-map-with-concurrency-limit', 'flatMapConcurLimit', 'obs.flatMapConcurLimit([fn], limit)').
  Like #[a(href='#flat-map-concat') flatMapConcat], но с настраиваемым количеством одновременных источников.
  Другими словами #[b flatMapConcat] это #[tt flatMapConcurLimit(fn, 1)].

pre.javascript(title='example')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2, 3]);
    var result = source.flatMapConcurLimit(x => Kefir.interval(40, x).take(6), 2);
    result.log();

pre(title='вывод')
  :escapehtml
    > [sequentially.flatMapConcurLimit] <value> 1
    > [sequentially.flatMapConcurLimit] <value> 1
    > [sequentially.flatMapConcurLimit] <value> 1
    > [sequentially.flatMapConcurLimit] <value> 2
    > [sequentially.flatMapConcurLimit] <value> 1
    > [sequentially.flatMapConcurLimit] <value> 2
    > [sequentially.flatMapConcurLimit] <value> 1
    > [sequentially.flatMapConcurLimit] <value> 2
    > [sequentially.flatMapConcurLimit] <value> 1
    > [sequentially.flatMapConcurLimit] <value> 2
    > [sequentially.flatMapConcurLimit] <value> 3
    > [sequentially.flatMapConcurLimit] <value> 2
    > [sequentially.flatMapConcurLimit] <value> 3
    > [sequentially.flatMapConcurLimit] <value> 2
    > [sequentially.flatMapConcurLimit] <value> 3
    > [sequentially.flatMapConcurLimit] <value> 3
    > [sequentially.flatMapConcurLimit] <value> 3
    > [sequentially.flatMapConcurLimit] <value> 3
    > [sequentially.flatMapConcurLimit] <end>

pre(title='события во времени').
  source:      ----------1---------2---------3X

  spawned 1:             ---1---1---1---1---1---1X
  spawned 2:                       ---2---2---2---2---2---2X
  spawned 3:                                     ---3---3---3---3---3---3X

  result:      -------------1---1---1-2-1-2-1-2-1-2-3-2-3-2-3---3---3---3X
div




+descr-method('flat-map-errors', 'flatMapErrors', 'obs.flatMapErrors([transform])').
  Same as #[a(href='#flat-map') flatMap],
  но работает с #[a(href='#about-errors') errors] в то время как #[b values] просто проходят.

pre.javascript(title='example')
  :escapehtml
    var source = Kefir.sequentially(100, [1, 2]).flatMap(Kefir.constantError);
    var result = source.flatMapErrors(x => Kefir.interval(40, x).take(2));
    result.log();

pre(title='вывод')
  :escapehtml
    > [sequentially.flatMap.flatMapErrors] <value> 1
    > [sequentially.flatMap.flatMapErrors] <value> 1
    > [sequentially.flatMap.flatMapErrors] <value> 2
    > [sequentially.flatMap.flatMapErrors] <value> 2
    > [sequentially.flatMap.flatMapErrors] <end>

pre(title='события во времени').
  source:      ----------e---------eX
                         1         2

  spawned 1:             ---1---1X
  spawned 2:                       ---2---2X

  result:      -------------1---1-----2---2X
div
