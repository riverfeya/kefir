h2#interop Взаимодействие с другими асинхронными абстракциями


+descr-method('from-promise', 'fromPromise', 'Kefir.fromPromise(promise)').
  Конвертирует Promise в Kefir Property. Использует интерфейс #[tt promise.then(onFulfilled, onRejected)]
  для подписки на promise. Также вызывает #[tt promise.done()]
  (если есть такие методы) чтобы предотвратить использование таких библиотек, как
  #[a(href='https://github.com/kriskowal/q') Q] или
  #[a(href='https://github.com/cujojs/when') when] или исключений, когда они проглатывают исключения.

pre.javascript(title='example')
  :escapehtml
    var result = Kefir.fromPromise(new Promise(fulfill => fulfill(1)));
    result.log();

pre(title='console output')
  :escapehtml
    > [fromPromise] <value> 1
    > [fromPromise] <end>

pre(title='events in time').
  result:  ----1X
div



+descr-method('to-promise', 'toPromise', 'obs.toPromise([PromiseConstructor])').
  Конвертирует Kefir Observable в Promise.
  Если вызывается без аргументов, используется конструктор по умолчанию #[tt gloabal.Promise],
  в качестве альтернативы вы можете передать конструктор promise
  который поддерживает следующий интерфейс: #[tt new Promise((resolve, reject) =&gt; { ... })].
  Promise будет выполнено или отклонено в момент окончания наблюдаемого источника
  с последним значением или ошибкой. 
  Если observable заканчивается без какого-либо значения или ошибки,
  promise никогда не будет выполнено/отклонено.

pre.javascript(title='example')
  :escapehtml
    var promise = Kefir.sequentially(1000, [1, 2]).toPromise();
    promise.then(x => {
      console.log('fulfilled with:', x);
    });

pre(title='console output')
  :escapehtml
    > fulfilled with: 2
div



+descr-method('from-es-observable', 'fromESObservable', 'Kefir.fromESObservable(observable)').
  Конвертирует #[a(href='https://github.com/zenparsing/es-observable') ECMAScript Observable]
  to в поток Kefir.

pre.javascript(title='example')
  :escapehtml
    var result = Kefir.fromESObservable(new Observable(observer => {
      observer.next(1);
      observer.next(2);
      observer.complete();
    }));
    result.log();

pre(title='console output')
  :escapehtml
    > [fromESObservable] <value> 1
    > [fromESObservable] <value> 2
    > [fromESObservable] <end>

pre(title='events in time').
  result:  12X
div




+descr-method('to-es-observable', 'toESObservable', 'obs.toESObservable()', 'obs[Symbol.observable]()').
  Конвертирует Kefir Observable в
  #[a(href='https://github.com/zenparsing/es-observable') ECMAScript Observable].

p.
  Также доступен как #[tt obs[Symbol.observable]], поэтому вы можете использовать метод ES Observable
  #[tt from] с Kefir Observables т.е., #[tt Observable.from(Kefir.sequentially(1000, [1, 2]))].

pre.javascript(title='example')
  :escapehtml
    var observable = Kefir.sequentially(1000, [1, 2]).toESObservable();
    observable.subscribe({
      next(x) {
        console.log('value:', x);
      },
      complete() {
        console.log('completed');
      }
    });

pre(title='console output')
  :escapehtml
    > value: 1
    > value: 2
    > completed
div



+descr-method('static-land', 'Static Land', 'Kefir.staticLand.Observable').
  Обеспечивает совместимость с #[a(href='https://github.com/rpominov/static-land') Static Land].
  Объект типа #[tt Observable] поддерживает следующие алгебры:
  Semigroup, Monoid, Functor, Bifunctor, Apply, Applicative, Chain, Monad.

pre.javascript(title='example')
  :escapehtml
    var Observable = Kefir.staticLand.Observable;
    var obs = Observable.map(x => x * 3, Observable.of(2));
    obs.log();

pre(title='console output')
  :escapehtml
    > [constant.map] <value:current> 6
    > [constant.map] <end:current>

p.
  #[a(href='https://github.com/rpominov/static-land') #[img(src='https://raw.githubusercontent.com/rpominov/static-land/master/logo/logo.png' width='80' height='50')]]
